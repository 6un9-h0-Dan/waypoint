syntax = "proto3";

package hashicorp.waypoint;

import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "google/rpc/status.proto";

// The service that is implemented for the server backend.
service Waypoint {
  // ListBuilds returns the builds.
  rpc ListBuilds(ListBuildsRequest) returns (ListBuildsResponse);

  // ListPushedArtifacts returns the builds.
  rpc ListPushedArtifacts(google.protobuf.Empty) returns (ListPushedArtifactsResponse);

  // ListDeployments returns the deployments.
  rpc ListDeployments(ListDeploymentsRequest) returns (ListDeploymentsResponse);

  // GetDeployment returns a deployment
  rpc GetDeployment(GetDeploymentRequest) returns (Deployment);

  // GetLatestBuild returns the most recent successfully completed build
  // for an app.
  rpc GetLatestBuild(GetLatestBuildRequest) returns (Build);

  // GetLatestPushedArtifact returns the most recent successfully completed
  // artifact push for an app.
  rpc GetLatestPushedArtifact(google.protobuf.Empty) returns (PushedArtifact);

  // GetLogStream reads the log stream for a deployment. This will immediately
  // send a single LogEntry with the lines we have so far. If there are no
  // available lines this will NOT block and instead will return an error.
  // The client can choose to retry or not.
  rpc GetLogStream(GetLogStreamRequest) returns (stream LogBatch);

  // StartExecStream starts an exec session.
  rpc StartExecStream(stream ExecStreamRequest) returns (stream ExecStreamResponse);

  //----------------------------------------------------------------------
  // Entrypoint binary endpoints. These are all expected to be called by
  // the entrypoint binary only.
  //----------------------------------------------------------------------

  // EntrypointConfig is called to get the configuration for the entrypoint
  // and also to get any potential updates.
  //
  // This endpoint also registers the instance with the server. This MUST be
  // called first otherwise other RPCs related to the entrypoint may fail
  // with FailedPrecondition.
  rpc EntrypointConfig(EntrypointConfigRequest) returns (stream EntrypointConfigResponse);

  // EntrypointLogStream is called to open the stream that logs are sent to.
  rpc EntrypointLogStream(stream EntrypointLogBatch) returns (google.protobuf.Empty);

  // EntrypointExecStream is called to open the data stream for the exec session.
  rpc EntrypointExecStream(stream EntrypointExecRequest) returns (stream EntrypointExecResponse);

  //----------------------------------------------------------------------
  // Internal metadata endpoints. The endpoints below are expected to be
  // called for internal bookkeeping only. They should be avoided for general
  // API clients since they can be used to damage internal state.
  //----------------------------------------------------------------------

  // UpsertBuild updates or inserts a build. A build is responsible for
  // taking some set of source information and turning it into an initial
  // artifact. This artifact is considered "local" until it is pushed.
  rpc UpsertBuild(UpsertBuildRequest) returns (UpsertBuildResponse);

  // UpsertPushedArtifact updates or inserts a pushed artifact. This is
  // useful for local operations to work on a pushed artifact.
  rpc UpsertPushedArtifact(UpsertPushedArtifactRequest) returns (UpsertPushedArtifactResponse);

  // UpsertDeployment updates or inserts a deployment.
  rpc UpsertDeployment(UpsertDeploymentRequest) returns (UpsertDeploymentResponse);

  // UpsertRelease updates or inserts a release.
  rpc UpsertRelease(UpsertReleaseRequest) returns (UpsertReleaseResponse);

  // Set a single configuration item for the application.
  rpc SetConfig(ConfigSetRequest) returns (ConfigSetResponse);

  // Retrieve configuration for the application.
  rpc GetConfig(ConfigGetRequest) returns (ConfigGetResponse);
}

message Application {
  Ref.Project project = 2;

  string name = 1;
}

message Project {
  string name = 1;
}

/********************************************************************
* Shared Messages
********************************************************************/

// Ref contains shared messages used for references to other resources.
message Ref {
  // Application references an application. To uniquely identify an
  // application, this must encapsulate the full hierarchy to the application.
  message Application {
    string application = 1;
    string project = 2;
  }

  // Project references a project.
  message Project {
    string project = 1;
  }
}

// Component represents metadata about a component. A component is the
// generic name for a builder, registry, platform, etc.
message Component {
  // type of the component
  Type type = 1;

  // name of the component
  string name = 2;

  // Supported component types, the values here MUST match the enum values
  // in the Go sdk/component package exactly. A test in internal/server
  // validates this.
  enum Type {
    UNKNOWN = 0;
    BUILDER = 1;
    REGISTRY = 2;
  }
}

// Status represents the status of an async operation.
message Status {
  // state is the state of this operation.
  State state = 1;

  // details may be non-empty to provide human-friendly information
  // about the current status. This may change between status updates
  // for the same state to provide updated details about the state.
  string details = 2;

  // error is set if the state == ERROR with the error that occurred.
  google.rpc.Status error = 3;

  // start_time is the time the operation was started.
  google.protobuf.Timestamp start_time = 4;

  // complete_time is the time the operation completed (success or fail).
  google.protobuf.Timestamp complete_time = 5;

  enum State {
    UNKNOWN = 0;
    RUNNING = 1;
    SUCCESS = 2;
    ERROR = 3;
  }
}

message StatusFilter {
  // Filters are ANDed together.
  repeated Filter filters = 1;

  message Filter {
    oneof filter {
      // state will match any status that has the given state.
      Status.State state = 2;
    }
  }
}

// OperationOrder is a shared message type used for controlling the order
// of results in queries for app operations such as build, deploys, etc.
message OperationOrder {
  // Order for the results.
  Order order = 2;
  bool order_desc = 3;

  // Limit the number of results
  uint32 limit = 4;

  enum Order {
    UNSET = 0;
    START_TIME = 1;
    COMPLETE_TIME = 2;
  }
}

/********************************************************************
* Build
********************************************************************/

message UpsertBuildRequest {
  // Build to upsert. If an ID is not set, this will be an insert operation.
  // If the ID is set, that build is updated. It is an error if an update
  // is requested on a non-existent build.
  Build build = 1;
}

message UpsertBuildResponse {
  Build build = 1;
}

message ListBuildsRequest {
  // The application whose builds to list. This must be set.
  Ref.Application application = 1;
}

message ListBuildsResponse {
  // builds is the list of builds.
  repeated Build builds = 1;
}

message GetLatestBuildRequest {
  Ref.Application application = 1;
}

// Build represents a process of creating an artifact that can be in any state,
// such as complete. A successful complete build produces an artifact.
message Build {
  // The application that this build is part of.
  Ref.Application application = 6;

  // id is the unique ID of the build
  string id = 1;

  // status of the build
  Status status = 2;

  // component is the component that was used for this build
  Component component = 3;

  // artifact is the result of the build if the status.state == SUCCESS
  Artifact artifact = 4;

  // labels are the set of labels that are present on this build.
  map<string,string> labels = 5;
}

// Artifact is the result of a build or registry. This is the metadata only.
// The binary contents of an artifact are expected to be stored in a registry.
message Artifact {
  // artifact is the full artifact encoded directly from the component plugin.
  // The receiving end must have access to the component proto files to
  // know how to decode this.
  google.protobuf.Any artifact = 1;
}

/********************************************************************
* Registry
********************************************************************/

message UpsertPushedArtifactRequest {
  // artifact to upsert. If the id in the artifact is empty, then this
  // will be an insert. Otherwise, this will be an update and if the ID
  // isn't found, it will be an error.
  PushedArtifact artifact = 1;
}

message UpsertPushedArtifactResponse {
  // resulting push object, you should replace this with what was sent
  // since the update operation may touch up the input data (i.e. update
  // timestamps)
  PushedArtifact artifact = 1;
}

message ListPushedArtifactsResponse {
  // artifacts is the list of artifacts.
  repeated PushedArtifact artifacts = 1;
}

message PushedArtifact {
  // id is a unique ID for this push
  string id = 1;

  // status of the push operation
  Status status = 2;

  // component that pushed this artifact
  Component component = 3;

  // artifact is the artifact that was a result from the push.
  Artifact artifact = 4;

  // the id of the build that this pushed artifact was sourced from.
  string build_id = 5;

  // labels are the set of labels that are present on this build.
  map<string,string> labels = 6;
}

/********************************************************************
* Platform
********************************************************************/

message GetDeploymentRequest {
  // Deployment to return.
  string deployment_id = 1;
}

message UpsertDeploymentRequest {
  // deployment to upsert. If the id in the artifact is empty, then this
  // will be an insert. Otherwise, this will be an update and if the ID
  // isn't found, it will be an error.
  Deployment deployment = 1;
}

message UpsertDeploymentResponse {
  // resulting object, you should replace this with what was sent in the request
  // since the update operation may touch up the input data (i.e. update
  // timestamps)
  Deployment deployment = 1;
}

message ListDeploymentsRequest {
  // The filters to apply to this request. These are ORed, so you should
  // specify multiple filters in the StatusFilter for AND behavior.
  repeated StatusFilter status = 1;

  // Order for the results.
  Order order = 2;
  bool order_desc = 3;

  // Limit the number of results
  uint32 limit = 4;

  enum Order {
    UNSET = 0;
    START_TIME = 1;
    COMPLETE_TIME = 2;
  }
}

message ListDeploymentsResponse {
  // deployments is the list of deployments.
  repeated Deployment deployments = 1;
}

message Deployment {
  // application that this deployment belongs to
  Ref.Application application = 8;

  // id is the unique ID for this deployment
  string id = 1;

  // state is the state of this deployment.
  State state = 2;

  // status of the current state of the deployment.
  Status status = 3;

  // component that initiated this deployment
  Component component = 4;

  // ID of the PushedArtifact that was deployed.
  string artifact_id = 5;

  // deployment is the full raw deployment object encoded directly from
  // the plugin. The client must have all the plugins setup to properly
  // decode this.
  google.protobuf.Any deployment = 6;

  // labels are the set of labels that are present on this build.
  map<string,string> labels = 7;

  enum State {
    UNKNOWN = 0;
    PENDING = 1;
    DEPLOY = 3;
    DESTROY = 4;
  };
}

/********************************************************************
* Release Management
********************************************************************/

message UpsertReleaseRequest {
  // release to upsert. If the id in the artifact is empty, then this
  // will be an insert. Otherwise, this will be an update and if the ID
  // isn't found, it will be an error.
  Release release = 1;
}

message UpsertReleaseResponse {
  // resulting object, you should replace this with what was sent in the request
  // since the update operation may touch up the input data (i.e. update
  // timestamps)
  Release release = 1;
}

message Release {
  // id is the unique ID for this release.
  string id = 1;

  // status of the release operation.
  Status status = 2;

  // component managing the release process.
  Component component = 3;

  // release is the raw release object encoded directly from the plugin.
  google.protobuf.Any release = 4;

  // split traffic between multiple deployments
  Split traffic_split = 5;

  // labels are the set of labels that are present on this build.
  map<string,string> labels = 6;

  message Split {
    repeated SplitTarget targets = 1;
  }

  message SplitTarget {
    // id the deployment target
    string deployment_id = 1;

    // percentage of traffic
    int32 percent = 2;
  }
}

/********************************************************************
* Logs
********************************************************************/

message GetLogStreamRequest {
  // Deployment to request logs for.
  string deployment_id = 1;
}

message LogBatch {
  string deployment_id = 1;
  string instance_id = 2;
  repeated Entry lines = 3;

  message Entry {
    google.protobuf.Timestamp timestamp = 1;
    string line = 2;
  }
}

/********************************************************************
* Exec
********************************************************************/

message ExecStreamRequest {
  oneof event {
    Start start = 1;
    Input input = 2;
    WindowSize winch = 3;
  }

  message Start {
    // Deployment to exec into
    string deployment_id = 1;

    // Args including the command at args[0] to execute.
    repeated string args = 2;

    // Pty is set if we should allocate a PTY for this exec stream.
    PTY pty = 3;
  }

  message Input {
    bytes data = 1;
  }

  message PTY {
    bool enable = 1;

    // term is the TERM value to request on the remote side. This should be set.
    string term = 2;

    // window_size is the initial window size
    WindowSize window_size = 3;
  }

  message WindowSize {
    int32 rows = 1;
    int32 cols = 2;
    int32 width = 3;
    int32 height = 4;
  }
}

message ExecStreamResponse {
  oneof event {
    Output output = 1;
    Exit exit = 2;
  }

  message Exit {
    int32 code = 1;
  }

  message Output {
    Channel channel = 1;
    bytes data = 2;

    enum Channel {
      UNKNOWN = 0;
      STDOUT  = 1;
      STDERR  = 2;
    }
  }
}

message ConfigVar {
  string name = 1;
  string value = 2;

  // Scope the variables just to the given application. If empty, the variables
  // will be project scoped.
  string app = 3;
}

message ConfigSetRequest {
  repeated ConfigVar variables = 1;
}

message ConfigSetResponse {}

message ConfigGetRequest {
  // Get all configuration entries under the given prefix. Therefore when empty, return
  // all configuration.
  string prefix = 1;

  // Get the configuration that would be applied to an application of the given name.
  // If empty, return configuration for all applications.
  string app = 2;
}

message ConfigGetResponse {
  repeated ConfigVar variables = 1;
}

/********************************************************************
* Entrypoint
********************************************************************/

message EntrypointConfigRequest {
  // id of the deployment that this instance is a part of
  string deployment_id = 1;

  // instance_id is a unique ID generated by the running entrypoint. This is
  // not an auth mechanism, just a way to associate data with the correct instance.
  string instance_id = 2;
}

message EntrypointConfigResponse {
  EntrypointConfig config = 2;
}

message EntrypointConfig {
  // Exec are requested exec sessions for this instance.
  repeated Exec exec = 1;

  repeated ConfigVar env_vars = 2;

  message Exec {
    int64 index = 1;
    repeated string args = 2;
    ExecStreamRequest.PTY pty = 3;
  }
}

// A batch of data for log streaming from the entrypoint.
message EntrypointLogBatch {
  // instance_id is a unique ID generated by the running entrypoint. This is
  // not an auth mechanism, just a way to associate data with the correct instance.
  string instance_id = 1;

  // lines is the set of lines
  repeated LogBatch.Entry lines = 2;
}

message EntrypointExecRequest {
  oneof event {
    // open MUST BE the first message sent by a client. This will be used
    // by the server side to perform some initialization. If the first message
    // is not open the server will close the connection.
    Open open = 1;

    // exit should be sent as a final message type after the command exits.
    Exit exit = 2;

    // output contains stdout/stderr
    Output output = 3;

    // error indicates an error occurred. This will terminate the stream.
    Error error = 4;
  }

  message Open {
    string instance_id = 1;
    int64 index = 2;
  }

  message Exit {
    int32 code = 1;
  }

  message Output {
    Channel channel = 1;
    bytes data = 2;

    enum Channel {
      UNKNOWN = 0;
      STDOUT  = 1;
      STDERR  = 2;
    }
  }

  message Error {
    google.rpc.Status error = 1;
  }
}

message EntrypointExecResponse {
  oneof event {
    // input is raw stdin input from the client
    bytes input = 1;

    // winch is SIGWNCH information for window sizing
    ExecStreamRequest.WindowSize winch = 2;

    // opened is sent when the entrypoint session is successfully opened.
    // The value of this message is meaningless. The existence of the message
    // itself is a signal that the stream was opened properly.
    bool opened = 3;
  }
}
